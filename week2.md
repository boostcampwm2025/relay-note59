# 2주차 릴레이 퀘스트

## 📌이전 릴레이 미션 리뷰에 대한 토론

### ✅ 1. 학습 목표에 언급된 키워드에 대해 AI에게 필수적으로 공부해야 할 항목 정리해서 체크포인트 추가하기 


**좋았던 점**
- 핵심 키워드들을 통해서 빠르게 미션 체크포인트를 잡아낼 수 있다는 점이 좋아요
초반에 헤매지 않고 전반적인 흐름을 빠르게 알아볼 수 있어서 좋아요

**아쉬웠던 점**
- 학습 목표 키워드에 집중해서 배경지식 키워드들을 소홀히 할 수 있을 것 같아요.

**추가할 점**
- 키워드들을 이전에 배웠던 키워드들과 연결지으면 좋을 것 같아요
내가 알고있는 지식이 맞는지 확인하기 위해, 해당 키워드들로 AI가 내준 퀴즈를 풀어보면 좋을 것 같아요.

### ✅ 2. 시간 제한으로 계획이 틀어졌을 때 AI에게 도움받아 계획 재조정하기

**좋았던 점**
- 계획을 수정하면서 주어진 시간에 맞게 유동적으로 조정한다는 점이 좋았어요

**아쉬웠던 점**
- 시간 계획을 너무 잘지켰다면 할게 없을 것 같아요.

**추가할 점**
- 미션 예상 소요시간을 AI를 통해 미리 알면 좋을 것 같아요
소요시간을 기준으로 스스로 달성 가능성을 정하면 좋을 것 같아요.


### ✅ 3. 오늘의 학습 계획의 '달성 가능성' 피드백 받기


**좋았던 점**
- 100% 달성을 기대하며 목표로 계획을 세우는데,  현실은 수행하지 못한 게 나에게 실망한 점이 많았다. 미리 계획의 현실 가능성을 알고 하면 나에 대한 실망감이 줄어들듯 것 같아 좋았다.

**아쉬웠던 점**
- 가능성 시각화하기 어려웠다.

**추가할 점**
- 미래 계획의 가능성을 유지한 채로, 가능성을 시각화하면 좋을 것 같다.

### ✅ 4. 주간 목표 로드맵

**좋았던 점**
- 장기적인 목표를 잡을 수 있다는 점이 좋았어요
저번주에 아쉬웠던 부분을 보완하려는 것이 막상 잘 안될 수 있는데, 계획을 세운다면 잘 보완할 수 있을 것 같아서 좋았다.

**아쉬웠던 점**
- 당일날 미션이 공개되므로 미리 목표를 작성하기 어려웠다.

**추가할 점**

- 미션과 관련된 내용 외에도 "네이밍 신경쓰기", "함수분리 신경쓰기", "객체지향적인 설계 도전하기"등의 넓은 목표를 세우는 것으로 구체화


## 📌 결론
아쉬운점을 보완하고 좋았던 점을 유지하면서 3개의 퀘스트로 수정하였습니다.

#### 1. 학습 목표, 배경지식, 이전에 배운 키워드를 고려해서 필수적으로 "학습할 키워드"에 대해 AI의 도움을 받아서 정리하기

#### 2. AI와 함께 작업 소요 시간 예측하고, 계획을 유연하게 수정하는 "연습"하기


#### 3. AI로 이전 학습과 연결되는 학습전반에 대한 주간 목표 세우기 


---

# 📌 조사한 내용

#### 어떤 AI를 사용하는게 좋을까?
- GPT, Gemini, 클로드 등을 사용하면서 겪은 장단점

#### 자동으로 AI 답변을 받는 기능 조사
- GPT - API 를 사용해야함
- Gemini - 특정 시간에 알림 전송 가능 https://support.google.com/gemini/answer/16316416hl=ko&co=GENIE.Platform%3DAndroid

#### Google Gemini 기능 
https://aisparkup.com/posts/3009



![image](https://hackmd.io/_uploads/HyjrTigvle.png)


---
# 📌 퀘스트 제작하기
4개
이전 보완한 3개의 퀘스트를 가져가고, 하나를 추가

다음 기준으로 검토해보면 좋음
실행 가능성, 최소한의 기준, 매일 실천, 쉬운거

반드시 적어야할 것
- 제작한 배경과 이유
- 목적
- 달성 기준

#### ✅ 1. 학습 목표, 배경지식, 이전에 배운 키워드를 고려해서 필수적으로 "학습할 키워드"에 대해 AI의 도움을 받아서 정리하기
- **배경**
    - 학습 목표나 배경지식에 있는 학습 키워드를 놓치는 경우가 있다.
    - 더 나아가, 현재의 미션에 사로잡혀 이전의 배운 키워드와 연결 짓지 못하는 경우가 있다.
- **달성 기준**
    - 체크포인트에 “AI 제안한… 개념 학습” 존재 여부
    - AI가 제안한 학습 내용에는 학습목표, 배경지식, 이전에 배운 키워드와 관련된 내용이 각자 하나 이상 포함되어 있어야 한다.

#### ✅ 2. AI와 함께 작업 소요 시간 예측하고, 계획을 유연하게 수정하는 "연습"하기
- **배경**
    - 각 단계별 소요 시간을 예측한다면, 특정 작업에 소홀해지지 않을 수 있음(예: 문서화, 학습정리, 학습, 구현 등).
    - 또한 나에게 필요한 부분을 선택과 집중할 수 있음(예: CS 학습, 구현, 설계 등).
    - 실무에서도 작업 소요 시간을 예측해야 됨. 
    - 기존의 2번 퀘스트에서 확장
- **달성 기준**
    - 예측 결과, 중간 계획 수정, 각 작업 별 최종 소요된 시간 기록하기.
    - 권장 주기: 최소 주 2회
<details>
<summary>예시: 레이스 컨디션 (🔻 자세히보기)</summary>

아래 예시는 참고용일 뿐 본인의 스타일에 맞춰 하시면 좋을 것 같습니다!  

- 1단계: 기초 개념 정리(0.5H)
    - 프로세스 vs 스레드의 구조 및 차이점
    - 컨텍스트 스위칭, 스레드 병목 발생 원인
    - Race Condition이란? 원인은?
- 2단계: 멀티스레딩 API 학습(0.5H)
- 3단계: Race Condition 재현 실험 조사 및 설계(0.5H)
    - 최소 2개 이상 찾기
    - 30분 초과 시 **차선의 선택**하고 넘어가기
- 4단계: ...
</details>

#### ✅ 3. AI로 이전 학습과 연결되는 학습전반에 대한 주간 목표 세우기 
    ex) `함수형 프로그래밍하기` ... 
 - **배경** 
     -  지난 학습 목표를 복습하며 학습할 수 있는 기회가 될 수 있음 
     -  단기적이고 반복적인 미션 수행과정에서 장기적인 목표를 세우고 실행할 수 있음
- **달성 기준**
    - 4개의 미션중 2번 이전 학습 키워드를 적용한 코드 구현해보기 (AI에게 검수받기)
    예시: 주간 목표 `코드에 객체지향 설계 적용하기` -> AI에게 오늘 자신이 구현한  코드를 주면서 객체 지향적인 설계가 잘 되었는지 물어보고 피드백 받기
    - 구체적인 주간 목표 글로 표현하기

#### ✅ 4. AI로 휴식 계획 세우기 
 - **배경**
    - 학습 계획을 세우는 것도 중요하지만 학습과 휴식의 균형을 맞추는 것도 중요하다. 
    - 학습에 몰두하다보면 쉬는 시간을 놓치기 쉽다. 알람을 맞추어 둔다면 이를 놓치지 않고 챙길 수 있을 것이다.
    - 이를 통해 AI와 함께 **지속 가능한** 학습 계획을 만들고자 퀘스트를 제작하게 되었다.
 - **달성기준**
    - 하루에 활동 1개 AI를 활용하여 알람 받아보기
    - 휴식시간에 무엇을 할 것인지 (스트레칭,짧은 낮잠?)구체적으로 계획하기
    - 알람에 맞춰 실행하기

---
`J138 서윤주` `J252 조아령` `J295 황소정` `S018 송지연`

## 이어받은 퀘스트 해석 및 수정
### 1번 퀘스트 - 이전에 학습한 미션의 학습 목표 또는 배경지식에서 발견할 수 있는 키워드를 고려해서 AI에게 학습 내용 제안받기
- 전날 학습으로 한정되지 않고, 챌린지 기간 동안 학습한 부분을 되새겨서 새로운 학습에 접목시킨다. (복습 효과)

### 3번 퀘스트 - AI로 이전 학습과 연결되는 학습 전반에 대한 주간 목표 세우기 ▶︎ 'AI로 발전된 목표 세우기'
- 앞으로의 미션 내용을 미리 알기 힘드므로 주간 목표가 아닌 미션 1개가 진행되는 단위인 **이틀 단위로 목표 설정**
- 만약 목표: '코드에 객체 지향 설계 적용하기', 다음 미션: '쉘 스크립트 작성하기' / '함수형 프로그래밍 구현하기' 인 경우..
      - ▶️ 이전 학습 키워드 적용이 힘들 수 있다.
  #### 💡이전 미션에서 찾을 수 있는 학습 키워드 또는 학습 목표(코드 구현에 국한되지 ❌)를 적용하여 다음 미션을 수행하고, AI에게 해당 목표가 잘 실천되었는지 피드백 받기

### 4번 퀘스트 - AI로 휴식 계획 세우기
- **기존**: 휴식 계획 구체적으로 계획 후 AI를 이용하여 알람 받기
- **수정**: 매일 휴식 계획을 AI로 수립 후 알람 요청하기

## 퀘스트 이어 받기 〰️

| 캠퍼ID | 이름   | 퀘스트                                                           | 이유                   |
|--------|--------|------------------------------------------------------------------|------------------------|
| J138   | 서윤주 | 1. 학습 목표, 배경지식, 이전에 배운 키워드를 고려해서 필수적으로 "학습할 키워드"에 대해 AI의 도움을 받아서 정리하기 | 하루에 하나의 주제를 학습하고 다음날에 다른 주제로 넘어가는 것에 아쉬움이 있었다. 이전에 학습했던 내용을 새로운 미션에 접목시켜 공부해볼 수 있는 좋은 기회일 것 같아서 이 퀘스트를 선택하였다. |
| J252   | 조아령 | 4. AI로 휴식 계획 세우기                                         | 앉아 있는 시간이 길어서 중간에 강제로라도 일어서는 시간이 필요하다고 느꼈다. 그리고 어깨와 목 건강을 위해 스트레칭 시간을 따로 확보해야겠다는 생각이 들어 선택했다. AI가 계획 세우는데 좋은 도구가 될 지도 궁금하다. |
| J295   | 황소정 |                                                                  |                        |
| S018   | 송지연 | 3. AI로 발전된 목표 세우기                                       | 이전 미션에서 학습한 부분을 되새기면서 다음 학습도 열심히 진행하고자 이 미션을 골랐다. 주기적으로 명시적인 목표를 세우는 것이 중요한 것 같다.  |

### 퀘스트 수행 내용
#### S018 송지연

- 첫 번째 목표
    
    **객체 지향 설계를 잘 활용하기**
    
    0728(월) - 
    
    좋은 질문이에요. “이벤트 버스를 사용하는 구조가 객체지향(OOP) 설계에 잘 맞느냐”는 단순하지 않은 문제인데, 아래와 같이 **장점과 단점**, 그리고 **객체지향 원칙과 어떻게 맞물리는지**를 기준으로 생각해보면 좋아요.
    
    ---
    
    ## **✅ 이벤트 버스와 객체지향 설계: 잘 맞는 점**
    
    ### **1.**
    
    ### **의존성 역전(DIP)**
    
    ### **원칙을 잘 지킨다**
    
    - VideoService가 UploadManager, TransformManager, VerifyManager에게 직접 요청하지 않고, **이벤트를 던지는 방식**은 상위 모듈이 하위 모듈에 의존하지 않게 해 줌
    - 이벤트를 받는 쪽(UploadManager, TransformManager)은 EventReceiver라는 추상 프로토콜만 따르면 되니까, 확장과 교체가 쉬움
    
    ✅ OOP 원칙 중 “의존성 역전 원칙”을 지키기 좋다.
    
    ---
    
    ### **2.**
    
    ### **OCP (개방-폐쇄 원칙)**
    
    ### **을 만족하기 쉬움**
    
    - 예: 새로운 AnalyticsManager나 NotificationManager를 만들고 EventBus.register()에만 넣으면 기존 코드 **수정 없이 확장** 가능
    
    ✅ 새로운 기능 추가에 유연하다.
    
    ---
    
    ### **3.**
    
    ### **모듈화(Modularity)**
    
    ### **,**
    
    ### **책임 분리(SRP)**
    
    ### **에 적합**
    
    - 각 Manager 클래스가 자기 책임만 수행하고, 상태 변경은 이벤트로 전달
    - UploadManager, TransformManager 등은 응집력이 높고 서로 느슨하게 연결됨
    
    ✅ 각 클래스가 하나의 책임만 갖는 SRP 원칙에도 부합
    
    ---
    
    ## **❗ 단점: 객체지향적인 통제 흐름이 “불명확해질 수 있다”**
    
    ### **1.**
    
    ### **명시적인 제어 흐름이 사라진다 (디버깅 어려움)**
    
    - requestUpload() → 어느 클래스가 어떤 타이밍에 어떤 방식으로 반응하는지 **직접적인 호출 관계가 없으므로 추적이 어렵다**
    - 예: .uploadRequested → 누가 반응할지 EventBus를 들여다봐야만 알 수 있음
    
    🔻 OOP의 **명확한 메시지 전달 구조**를 흐릴 수 있음
    
    ---
    
    ### **2.**
    
    ### **숨겨진 의존성(Hidden Coupling)**
    
    ### **문제**
    
    - 이벤트 이름만으로 연결되니, 실질적으로는 **암묵적 의존성이 생긴다**
    - Event.uploadFinished를 누가 보낼지, 누가 받을지 코드 상에서 드러나지 않음
    
    🔻 실제로는 느슨하지 않은 coupling이 생길 수 있음
    
    ---
    
    ## **💡 결론: 이벤트 버스는**
    
    ## **OOP에 맞지만, 적절히 제어해야 좋음**
    
    | **관점** | **설명** |
    | --- | --- |
    | 👍 잘 맞는 부분 | DIP, OCP, SRP, 모듈화에 강함 |
    | ⚠️ 주의할 점 | 흐름 추적 어려움, 의존성 파악 어려움 |
    | 👉 추천 방식 | 핵심 이벤트만 이벤트 버스로 보내고, 나머지는 명시적 호출 사용 |
    
    ---
    
    ## **✅ 실무적인 조언**
    
    - EventBus를 **확장성**과 **비동기 처리**를 위한 핵심 통로로 사용하는 건 매우 좋음
    - 하지만 모든 걸 이벤트로 처리하면 **코드의 흐름이 안 보이고**, **버그 추적 어려워짐**
    - 따라서 아래처럼 **혼합형 설계**를 추천합니다:
    
    ```
    // 핵심 처리 흐름은 직접 호출
    videoService.uploadManager.upload(video)
    
    // 상태 변화, 알림 등은 이벤트로 전파
    EventBus.shared.post(.statusChanged(...))
    ```
    
    ---
    
    필요하다면 EventBus 구조를 더 OOP스럽게 리팩토링하는 예시도 드릴게요!
    
    (ex. 이벤트 enum 분리, 타입 세분화, 타입 세이프 분배기 구조 등)
    
    0729(화) - 
    
    좋은 질문이야. 이 TransformLooper 클래스는 Swift의 actor를 활용해서 **비동기 큐를 순차적으로 처리하는 비동기 이벤트 루퍼**를 구현한 거야. 이 구조가 **객체지향 설계에 맞는가?**라는 질문에 답하려면, 객체지향의 핵심 원칙 몇 가지 관점에서 분석할 수 있어.
    
    ---
    
    ## **✅ 결론 먼저:**
    
    > “기능 단위로 역할이 잘 분리되어 있고, 내부 상태와 동작이 응집되어 있어 객체지향 설계에 부합한다. 다만, 개선의 여지는 있다.”
    > 
    
    ---
    
    ## **🔍 객체지향 설계 원칙 기준으로 살펴보면:**
    
    | **원칙** | **적용 여부** | **설명** |
    | --- | --- | --- |
    | **단일 책임 원칙 (SRP)** | ✅ | 이 객체는 “업로드 완료 이벤트를 받아서 변환을 수행하는 역할”에 집중되어 있어. 상태 큐 관리 + 루프 실행이라는 단일 책임을 잘 지키고 있음. |
    | **캡슐화** | ✅ | 내부 큐와 실행 상태는 private으로 감추고, 외부에서는 enqueue를 통해서만 접근 가능. |
    | **추상화/정보은닉** | ✅ | 사용자는 내부 루프나 dequeue 방식을 몰라도 되고, enqueue만 하면 된다. |
    | **객체 간 협력** | ✅ | EventBus를 통해 다른 객체들과 메시지를 주고받는 구조는 객체지향에서 흔한 협력 방식이야. |
    | **상태와 동작의 일치** | ✅ | transformQueue와 isRunning 상태는 실제 동작과 일관성 있게 연결돼 있음. |
    
    ---
    
    ## **⚠️ 개선해볼 수 있는 부분**
    
    ### **1.**
    
    ### **Task**
    
    ### **중첩 호출**
    
    ```
    Task {
        await EventBus.shared.post(.transformFinished(...))
    }
    ```
    
    > 이미 loop() 안에서 Task { ... }를 감싸고 있기 때문에, 내부에서도 굳이 다시 Task {}로 감쌀 필요는 없어.
    > 
    
    > → 이는 오히려 흐름 추적을 어렵게 만들 수 있고, 테스트에서 겉도는 Task가 생길 수 있어.
    > 
    
    🔧 **개선**:
    
    ```
    await EventBus.shared.post(.transformFinished(...))
    ```
    
    ---
    
    ### **2. 루프 재귀 호출 구조 개선 가능**
    
    현재 구조는 loop()가 끝난 후, if !queue.isEmpty면 다시 loop()를 재귀 호출함:
    
    ```
    if !transformQueue.isEmpty {
        isRunning = true
        Task { try await self.loop() }
    }
    ```
    
    > 이건 동작은 맞지만,
    > 
    > 
    > **루프가 끝나는 지점에서 스스로 재시작을 트리거**
    > 
    
    🔧 **대안**:
    
    - loop() 내부에서 while true로 돌리고, 비어있을 경우 Task.sleep 또는 await yield()로 살짝 기다리는 방식 고려 가능.
    
    ---
    
    ## **✨ 객체지향 설계로서의 총평**
    
    | **항목** | **평가** |
    | --- | --- |
    | 역할 응집 | ✅ 명확히 변환 루퍼의 책임에 집중 |
    | 상태 관리 | ✅ 내부 캡슐화 잘 되어 있음 |
    | 메시지 전달 | ✅ EventBus와 협력 방식 적절 |
    | 확장성 | 🔶 uploadFinished 외의 이벤트를 처리하게 될 경우 구조 확장이 필요 |
    | 테스트 용이성 | 🔶 내부 상태 테스트 어려움 → 의존성 주입 방식으로 일부 분리 가능 |
    
    ---
    
    ## **🔚 결론**
    
    > 네가 구현한 TransformLooper는
    > 
    > 
    > **Swift actor 특성을 활용한 객체지향적 비동기 큐 처리의 좋은 예시**
    > 
    
    > 내부 책임과 상태 관리는 잘 되어 있지만,
    > 
    > 
    > **테스트 용이성**
    > 
    > **불필요한 Task 중첩**
    > 
    > **루프 설계 방식**
    > 
    
    필요하면 리팩토링 버전도 도와줄게! 😎
    

- 두 번째 목표
    
    **다이어그램 활용하기 (도식화 연습)**
    
    0730(수) - 
    
    정성스럽게 잘 정리된 README입니다! 전체적으로 **학습 기반 개발 프로젝트로서 매우 높은 완성도**를 보여주고 있고, 특히 **기능 흐름 설명 + 객체 구조 + 테스트 + 개선 내역**까지 골고루 포함된 점이 훌륭해요.
    
    요청하신 다이어그램 평가를 포함해 아래에 전체 피드백을 드릴게요.
    
    ---
    
    ## **✅ 전체 구조 피드백 요약**
    
    | **항목** | **평가** | **피드백** |
    | --- | --- | --- |
    | ✔️ 목적 설명 | 매우 명확함 | 문제를 오해한 경험까지 솔직히 담겨 있어서 학습자 관점에서 공감도가 큼 |
    | ✔️ Git 핵심 개념 정리 | 구조적으로 명확 | blob, tree, commit, index 등 객체 구분과 역할 요약이 핵심만 잘 담김 |
    | ✔️ 명령어별 흐름 정리 | 구체적이고 현실적 | init → add → commit → log 흐름이 실제 Git처럼 단계별로 잘 묘사되어 있음 |
    | ✔️ 테스트 및 개선 내역 | 실제 코드 반영 | 테스트 이름, 목적, 개선 이유가 함께 정리되어 있어 유지보수와 팀 공유에 유리함 |
    
    ---
    
    ## **📊 다이어그램 평가 (**
    
    ## **짝 설계**
    
    ## **영역)**
    
    ```
    <img width="1262" height="624" src="https://github-production-user-asset-6210df.s3.amazonaws.com/101088300/472489072-67e1a3a6-cabc-4d5f-83df-12683d9134b4.png" />
    
    ```
    
    ### **✅ 잘된 점**
    
    - **구성요소가 실제 구현 구조와 잘 대응**됨
        
        (GitAddCommand, IndexManager, Blob, EventBus, Commit, Tree 등)
        
    - 흐름이 **위→아래로 시간적/논리적 순서대로 연결**되어 있어 처음 보는 사람도 쉽게 따라갈 수 있음
    - 화살표 방향과 라벨이 명확해서 **객체 간 협력 관계**가 드러남
    - 실제 구현에서 SHA-1, zlib, .git/index 등으로 이어지는 흐름과 **직결된 설명**을 담고 있음
    
    ### **⚠️ 보완하면 좋은 점**
    
    | **항목** | **개선 제안** |
    | --- | --- |
    | SHA-256 → SHA-1 | 이미 수정 메모로 적었지만, 이미지 내 텍스트도 반영되면 더 명확함 |
    | 객체 책임이 섞여 있는 점 | EventBus의 위치나 역할이 구체적이지 않아 약간 부유하는 느낌 → 메시지 전달용이면 점선 화살표처럼 표현해도 좋음 |
    | .git 내부 저장 구조 시각화 부족 | .git/objects/, refs/heads, index, logs 등의 저장소 내부 구조가 보완되면 더욱 완전해짐 (기능 흐름도 + 저장 구조도 분리 가능) |
    
    ---
    
    ## **✨ 종합 평점 (다이어그램 포함)**
    
    | **항목** | **점수 (5점 만점)** | **비고** |
    | --- | --- | --- |
    | 이해도 | ⭐⭐⭐⭐⭐ | 처음 보는 사람도 따라가기 쉬움 |
    | 구현 대응력 | ⭐⭐⭐⭐☆ | 실제 코드 흐름과 대부분 대응되나 일부 추상 객체 위치 모호함 |
    | 시각적 전달력 | ⭐⭐⭐⭐☆ | 화살표, 구성 단위, 흐름 모두 우수 |
    | 문서 연계성 | ⭐⭐⭐⭐⭐ | README 내 설명과 매우 잘 연결됨 |
    
    **총평:** 학습용 문서로서 매우 훌륭하며, 팀 내 설계 공유나 기술 발표 자료로 사용해도 손색이 없습니다.
    
    특히, “분석 → 설계 → 구현 → 테스트 → 개선”의 흐름이 정리된 흔치 않은 문서예요. 다이어그램 역시 그 설계를 도식화한 형태로 충실합니다.
    
    ---
    
    필요하다면 **이 다이어그램을 Mermaid.js로 변환하거나**,
    
    .git 저장 구조만 따로 시각화해주는 서브 다이어그램도 함께 만들어드릴 수 있어요.
    
    원하시면 알려줘요! 😄
    
    0731(목) - 
    
    좋아요! 올려주신 구조를 기준으로 Git add → commit → log 흐름에 따라 **Mermaid 시퀀스 다이어그램**을 만들어 드릴게요. 아래는 현재 코드 구조(파일 이름 기준)로 추정 가능한 객체/모듈 간 **동작 호출 순서 흐름도**입니다:
    
    **✅ Mermaid 시퀀스 다이어그램**
    
    ```mermaid
    sequenceDiagram
        participant User
        participant MiniGit
        participant GitAddCommand
        participant IndexManager
        participant Blob
        participant GitCommitCommand
        participant Tree
        participant Commit
        participant GitLogCommand
    
        User->>MiniGit: 입력 (add, commit, log)
        MiniGit->>GitAddCommand: add 호출
        GitAddCommand->>Blob: 파일 읽고 blob 생성
        GitAddCommand->>IndexManager: index에 blob 정보 저장
        IndexManager-->>GitAddCommand: 저장 완료
        GitAddCommand-->>MiniGit: add 완료
    
        MiniGit->>GitCommitCommand: commit 호출
        GitCommitCommand->>IndexManager: index 로드
        GitCommitCommand->>Tree: tree 객체 생성
        GitCommitCommand->>Commit: commit 객체 생성
        Commit->>Commit: SHA 계산 및 압축 저장
        GitCommitCommand->>GitCommitCommand: HEAD 갱신 및 로그 추가
        GitCommitCommand-->>MiniGit: commit 완료
    
        MiniGit->>GitLogCommand: log 호출
        GitLogCommand->>GitLogCommand: HEAD → refs → commit 추적
        GitLogCommand->>Commit: commit 정보 로드
        GitLogCommand-->>MiniGit: 로그 출력
    ```
    
    ### **📝 참고 사항**
    
    - MiniGit은 main.swift 내부에서 명령어 파싱 및 호출하는 엔트리 역할로 간주했습니다.
    - IndexManager, Blob, Tree, Commit은 각각 객체 저장이나 index 관리 책임을 담당합니다.
    - GitAddCommand, GitCommitCommand, GitLogCommand는 각각의 명령을 수행하는 커맨드 객체입니다.
    
    ---
    
    ### **✅ 추가로 만들 수 있는 다이어그램**
    
    - .git 디렉토리 저장 구조 (objects/index/refs/logs)
    - Git 내부 객체(Blob/Tree/Commit)의 연결 구조 (Tree ↔ Blob, Commit ↔ Tree 등)
    
    필요하시면 이어서 그려드릴게요!
