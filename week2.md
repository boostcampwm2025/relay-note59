# 2주차 릴레이 퀘스트

## 📌이전 릴레이 미션 리뷰에 대한 토론

### ✅ 1. 학습 목표에 언급된 키워드에 대해 AI에게 필수적으로 공부해야 할 항목 정리해서 체크포인트 추가하기 


**좋았던 점**
- 핵심 키워드들을 통해서 빠르게 미션 체크포인트를 잡아낼 수 있다는 점이 좋아요
초반에 헤매지 않고 전반적인 흐름을 빠르게 알아볼 수 있어서 좋아요

**아쉬웠던 점**
- 학습 목표 키워드에 집중해서 배경지식 키워드들을 소홀히 할 수 있을 것 같아요.

**추가할 점**
- 키워드들을 이전에 배웠던 키워드들과 연결지으면 좋을 것 같아요
내가 알고있는 지식이 맞는지 확인하기 위해, 해당 키워드들로 AI가 내준 퀴즈를 풀어보면 좋을 것 같아요.

### ✅ 2. 시간 제한으로 계획이 틀어졌을 때 AI에게 도움받아 계획 재조정하기

**좋았던 점**
- 계획을 수정하면서 주어진 시간에 맞게 유동적으로 조정한다는 점이 좋았어요

**아쉬웠던 점**
- 시간 계획을 너무 잘지켰다면 할게 없을 것 같아요.

**추가할 점**
- 미션 예상 소요시간을 AI를 통해 미리 알면 좋을 것 같아요
소요시간을 기준으로 스스로 달성 가능성을 정하면 좋을 것 같아요.


### ✅ 3. 오늘의 학습 계획의 '달성 가능성' 피드백 받기


**좋았던 점**
- 100% 달성을 기대하며 목표로 계획을 세우는데,  현실은 수행하지 못한 게 나에게 실망한 점이 많았다. 미리 계획의 현실 가능성을 알고 하면 나에 대한 실망감이 줄어들듯 것 같아 좋았다.

**아쉬웠던 점**
- 가능성 시각화하기 어려웠다.

**추가할 점**
- 미래 계획의 가능성을 유지한 채로, 가능성을 시각화하면 좋을 것 같다.

### ✅ 4. 주간 목표 로드맵

**좋았던 점**
- 장기적인 목표를 잡을 수 있다는 점이 좋았어요
저번주에 아쉬웠던 부분을 보완하려는 것이 막상 잘 안될 수 있는데, 계획을 세운다면 잘 보완할 수 있을 것 같아서 좋았다.

**아쉬웠던 점**
- 당일날 미션이 공개되므로 미리 목표를 작성하기 어려웠다.

**추가할 점**

- 미션과 관련된 내용 외에도 "네이밍 신경쓰기", "함수분리 신경쓰기", "객체지향적인 설계 도전하기"등의 넓은 목표를 세우는 것으로 구체화


## 📌 결론
아쉬운점을 보완하고 좋았던 점을 유지하면서 3개의 퀘스트로 수정하였습니다.

#### 1. 학습 목표, 배경지식, 이전에 배운 키워드를 고려해서 필수적으로 "학습할 키워드"에 대해 AI의 도움을 받아서 정리하기

#### 2. AI와 함께 작업 소요 시간 예측하고, 계획을 유연하게 수정하는 "연습"하기


#### 3. AI로 이전 학습과 연결되는 학습전반에 대한 주간 목표 세우기 


---

# 📌 조사한 내용

#### 어떤 AI를 사용하는게 좋을까?
- GPT, Gemini, 클로드 등을 사용하면서 겪은 장단점

#### 자동으로 AI 답변을 받는 기능 조사
- GPT - API 를 사용해야함
- Gemini - 특정 시간에 알림 전송 가능 https://support.google.com/gemini/answer/16316416hl=ko&co=GENIE.Platform%3DAndroid

#### Google Gemini 기능 
https://aisparkup.com/posts/3009



![image](https://hackmd.io/_uploads/HyjrTigvle.png)


---
# 📌 퀘스트 제작하기
4개
이전 보완한 3개의 퀘스트를 가져가고, 하나를 추가

다음 기준으로 검토해보면 좋음
실행 가능성, 최소한의 기준, 매일 실천, 쉬운거

반드시 적어야할 것
- 제작한 배경과 이유
- 목적
- 달성 기준

#### ✅ 1. 학습 목표, 배경지식, 이전에 배운 키워드를 고려해서 필수적으로 "학습할 키워드"에 대해 AI의 도움을 받아서 정리하기
- **배경**
    - 학습 목표나 배경지식에 있는 학습 키워드를 놓치는 경우가 있다.
    - 더 나아가, 현재의 미션에 사로잡혀 이전의 배운 키워드와 연결 짓지 못하는 경우가 있다.
- **달성 기준**
    - 체크포인트에 “AI 제안한… 개념 학습” 존재 여부
    - AI가 제안한 학습 내용에는 학습목표, 배경지식, 이전에 배운 키워드와 관련된 내용이 각자 하나 이상 포함되어 있어야 한다.

#### ✅ 2. AI와 함께 작업 소요 시간 예측하고, 계획을 유연하게 수정하는 "연습"하기
- **배경**
    - 각 단계별 소요 시간을 예측한다면, 특정 작업에 소홀해지지 않을 수 있음(예: 문서화, 학습정리, 학습, 구현 등).
    - 또한 나에게 필요한 부분을 선택과 집중할 수 있음(예: CS 학습, 구현, 설계 등).
    - 실무에서도 작업 소요 시간을 예측해야 됨. 
    - 기존의 2번 퀘스트에서 확장
- **달성 기준**
    - 예측 결과, 중간 계획 수정, 각 작업 별 최종 소요된 시간 기록하기.
    - 권장 주기: 최소 주 2회
<details>
<summary>예시: 레이스 컨디션 (🔻 자세히보기)</summary>

아래 예시는 참고용일 뿐 본인의 스타일에 맞춰 하시면 좋을 것 같습니다!  

- 1단계: 기초 개념 정리(0.5H)
    - 프로세스 vs 스레드의 구조 및 차이점
    - 컨텍스트 스위칭, 스레드 병목 발생 원인
    - Race Condition이란? 원인은?
- 2단계: 멀티스레딩 API 학습(0.5H)
- 3단계: Race Condition 재현 실험 조사 및 설계(0.5H)
    - 최소 2개 이상 찾기
    - 30분 초과 시 **차선의 선택**하고 넘어가기
- 4단계: ...
</details>

#### ✅ 3. AI로 이전 학습과 연결되는 학습전반에 대한 주간 목표 세우기 
    ex) `함수형 프로그래밍하기` ... 
 - **배경** 
     -  지난 학습 목표를 복습하며 학습할 수 있는 기회가 될 수 있음 
     -  단기적이고 반복적인 미션 수행과정에서 장기적인 목표를 세우고 실행할 수 있음
- **달성 기준**
    - 4개의 미션중 2번 이전 학습 키워드를 적용한 코드 구현해보기 (AI에게 검수받기)
    예시: 주간 목표 `코드에 객체지향 설계 적용하기` -> AI에게 오늘 자신이 구현한  코드를 주면서 객체 지향적인 설계가 잘 되었는지 물어보고 피드백 받기
    - 구체적인 주간 목표 글로 표현하기

#### ✅ 4. AI로 휴식 계획 세우기 
 - **배경**
    - 학습 계획을 세우는 것도 중요하지만 학습과 휴식의 균형을 맞추는 것도 중요하다. 
    - 학습에 몰두하다보면 쉬는 시간을 놓치기 쉽다. 알람을 맞추어 둔다면 이를 놓치지 않고 챙길 수 있을 것이다.
    - 이를 통해 AI와 함께 **지속 가능한** 학습 계획을 만들고자 퀘스트를 제작하게 되었다.
 - **달성기준**
    - 하루에 활동 1개 AI를 활용하여 알람 받아보기
    - 휴식시간에 무엇을 할 것인지 (스트레칭,짧은 낮잠?)구체적으로 계획하기
    - 알람에 맞춰 실행하기

---
`J138 서윤주` `J252 조아령` `J295 황소정` `S018 송지연`

## 이어받은 퀘스트 해석 및 수정
### 1번 퀘스트 - 이전에 학습한 미션의 학습 목표 또는 배경지식에서 발견할 수 있는 키워드를 고려해서 AI에게 학습 내용 제안받기
- 전날 학습으로 한정되지 않고, 챌린지 기간 동안 학습한 부분을 되새겨서 새로운 학습에 접목시킨다. (복습 효과)

### 3번 퀘스트 - AI로 이전 학습과 연결되는 학습 전반에 대한 주간 목표 세우기 ▶︎ 'AI로 발전된 목표 세우기'
- 앞으로의 미션 내용을 미리 알기 힘드므로 주간 목표가 아닌 미션 1개가 진행되는 단위인 **이틀 단위로 목표 설정**
- 만약 목표: '코드에 객체 지향 설계 적용하기', 다음 미션: '쉘 스크립트 작성하기' / '함수형 프로그래밍 구현하기' 인 경우..
      - ▶️ 이전 학습 키워드 적용이 힘들 수 있다.
  #### 💡이전 미션에서 찾을 수 있는 학습 키워드 또는 학습 목표(코드 구현에 국한되지 ❌)를 적용하여 다음 미션을 수행하고, AI에게 해당 목표가 잘 실천되었는지 피드백 받기

### 4번 퀘스트 - AI로 휴식 계획 세우기
- **기존**: 휴식 계획 구체적으로 계획 후 AI를 이용하여 알람 받기
- **수정**: 매일 휴식 계획을 AI로 수립 후 알람 요청하기

## 퀘스트 이어 받기 〰️

| 캠퍼ID | 이름   | 퀘스트                                                           | 이유                   |
|--------|--------|------------------------------------------------------------------|------------------------|
| J138   | 서윤주 | 1. 학습 목표, 배경지식, 이전에 배운 키워드를 고려해서 필수적으로 "학습할 키워드"에 대해 AI의 도움을 받아서 정리하기 | 하루에 하나의 주제를 학습하고 다음날에 다른 주제로 넘어가는 것에 아쉬움이 있었다. 이전에 학습했던 내용을 새로운 미션에 접목시켜 공부해볼 수 있는 좋은 기회일 것 같아서 이 퀘스트를 선택하였다. |
| J252   | 조아령 | 4. AI로 휴식 계획 세우기                                         | 앉아 있는 시간이 길어서 중간에 강제로라도 일어서는 시간이 필요하다고 느꼈다. 그리고 어깨와 목 건강을 위해 스트레칭 시간을 따로 확보해야겠다는 생각이 들어 선택했다. AI가 계획 세우는데 좋은 도구가 될 지도 궁금하다. |
| J295   | 황소정 | 2. AI와 함께 작업 소요 시간 예측하고, 계획을 유연하게 수정하는 "연습"하기 | 시간관리를 구체적으로 설정하고 그 시간안에 할려고 노력하면서 마감이 있는 것처럼 하여, 시간관리가 더 잘 될 수 있을 것 같아 선택하였습니다. |
| S018   | 송지연 | 3. AI로 발전된 목표 세우기                                       | 이전 미션에서 학습한 부분을 되새기면서 다음 학습도 열심히 진행하고자 이 미션을 골랐다. 주기적으로 명시적인 목표를 세우는 것이 중요한 것 같다.  |

### 퀘스트 수행 내용
#### S018 송지연

- 첫 번째 목표
    
    **객체 지향 설계를 잘 활용하기**
    
    0728(월) - 
    
    좋은 질문이에요. “이벤트 버스를 사용하는 구조가 객체지향(OOP) 설계에 잘 맞느냐”는 단순하지 않은 문제인데, 아래와 같이 **장점과 단점**, 그리고 **객체지향 원칙과 어떻게 맞물리는지**를 기준으로 생각해보면 좋아요.
    
    ---
    
    ## **✅ 이벤트 버스와 객체지향 설계: 잘 맞는 점**
    
    ### **1.**
    
    ### **의존성 역전(DIP)**
    
    ### **원칙을 잘 지킨다**
    
    - VideoService가 UploadManager, TransformManager, VerifyManager에게 직접 요청하지 않고, **이벤트를 던지는 방식**은 상위 모듈이 하위 모듈에 의존하지 않게 해 줌
    - 이벤트를 받는 쪽(UploadManager, TransformManager)은 EventReceiver라는 추상 프로토콜만 따르면 되니까, 확장과 교체가 쉬움
    
    ✅ OOP 원칙 중 “의존성 역전 원칙”을 지키기 좋다.
    
    ---
    
    ### **2.**
    
    ### **OCP (개방-폐쇄 원칙)**
    
    ### **을 만족하기 쉬움**
    
    - 예: 새로운 AnalyticsManager나 NotificationManager를 만들고 EventBus.register()에만 넣으면 기존 코드 **수정 없이 확장** 가능
    
    ✅ 새로운 기능 추가에 유연하다.
    
    ---
    
    ### **3.**
    
    ### **모듈화(Modularity)**
    
    ### **,**
    
    ### **책임 분리(SRP)**
    
    ### **에 적합**
    
    - 각 Manager 클래스가 자기 책임만 수행하고, 상태 변경은 이벤트로 전달
    - UploadManager, TransformManager 등은 응집력이 높고 서로 느슨하게 연결됨
    
    ✅ 각 클래스가 하나의 책임만 갖는 SRP 원칙에도 부합
    
    ---
    
    ## **❗ 단점: 객체지향적인 통제 흐름이 “불명확해질 수 있다”**
    
    ### **1.**
    
    ### **명시적인 제어 흐름이 사라진다 (디버깅 어려움)**
    
    - requestUpload() → 어느 클래스가 어떤 타이밍에 어떤 방식으로 반응하는지 **직접적인 호출 관계가 없으므로 추적이 어렵다**
    - 예: .uploadRequested → 누가 반응할지 EventBus를 들여다봐야만 알 수 있음
    
    🔻 OOP의 **명확한 메시지 전달 구조**를 흐릴 수 있음
    
    ---
    
    ### **2.**
    
    ### **숨겨진 의존성(Hidden Coupling)**
    
    ### **문제**
    
    - 이벤트 이름만으로 연결되니, 실질적으로는 **암묵적 의존성이 생긴다**
    - Event.uploadFinished를 누가 보낼지, 누가 받을지 코드 상에서 드러나지 않음
    
    🔻 실제로는 느슨하지 않은 coupling이 생길 수 있음
    
    ---
    
    ## **💡 결론: 이벤트 버스는**
    
    ## **OOP에 맞지만, 적절히 제어해야 좋음**
    
    | **관점** | **설명** |
    | --- | --- |
    | 👍 잘 맞는 부분 | DIP, OCP, SRP, 모듈화에 강함 |
    | ⚠️ 주의할 점 | 흐름 추적 어려움, 의존성 파악 어려움 |
    | 👉 추천 방식 | 핵심 이벤트만 이벤트 버스로 보내고, 나머지는 명시적 호출 사용 |
    
    ---
    
    ## **✅ 실무적인 조언**
    
    - EventBus를 **확장성**과 **비동기 처리**를 위한 핵심 통로로 사용하는 건 매우 좋음
    - 하지만 모든 걸 이벤트로 처리하면 **코드의 흐름이 안 보이고**, **버그 추적 어려워짐**
    - 따라서 아래처럼 **혼합형 설계**를 추천합니다:
    
    ```
    // 핵심 처리 흐름은 직접 호출
    videoService.uploadManager.upload(video)
    
    // 상태 변화, 알림 등은 이벤트로 전파
    EventBus.shared.post(.statusChanged(...))
    ```
    
    ---
    
    필요하다면 EventBus 구조를 더 OOP스럽게 리팩토링하는 예시도 드릴게요!
    
    (ex. 이벤트 enum 분리, 타입 세분화, 타입 세이프 분배기 구조 등)
    
    0729(화) - 
    
    좋은 질문이야. 이 TransformLooper 클래스는 Swift의 actor를 활용해서 **비동기 큐를 순차적으로 처리하는 비동기 이벤트 루퍼**를 구현한 거야. 이 구조가 **객체지향 설계에 맞는가?**라는 질문에 답하려면, 객체지향의 핵심 원칙 몇 가지 관점에서 분석할 수 있어.
    
    ---
    
    ## **✅ 결론 먼저:**
    
    > “기능 단위로 역할이 잘 분리되어 있고, 내부 상태와 동작이 응집되어 있어 객체지향 설계에 부합한다. 다만, 개선의 여지는 있다.”
    > 
    
    ---
    
    ## **🔍 객체지향 설계 원칙 기준으로 살펴보면:**
    
    | **원칙** | **적용 여부** | **설명** |
    | --- | --- | --- |
    | **단일 책임 원칙 (SRP)** | ✅ | 이 객체는 “업로드 완료 이벤트를 받아서 변환을 수행하는 역할”에 집중되어 있어. 상태 큐 관리 + 루프 실행이라는 단일 책임을 잘 지키고 있음. |
    | **캡슐화** | ✅ | 내부 큐와 실행 상태는 private으로 감추고, 외부에서는 enqueue를 통해서만 접근 가능. |
    | **추상화/정보은닉** | ✅ | 사용자는 내부 루프나 dequeue 방식을 몰라도 되고, enqueue만 하면 된다. |
    | **객체 간 협력** | ✅ | EventBus를 통해 다른 객체들과 메시지를 주고받는 구조는 객체지향에서 흔한 협력 방식이야. |
    | **상태와 동작의 일치** | ✅ | transformQueue와 isRunning 상태는 실제 동작과 일관성 있게 연결돼 있음. |
    
    ---
    
    ## **⚠️ 개선해볼 수 있는 부분**
    
    ### **1.**
    
    ### **Task**
    
    ### **중첩 호출**
    
    ```
    Task {
        await EventBus.shared.post(.transformFinished(...))
    }
    ```
    
    > 이미 loop() 안에서 Task { ... }를 감싸고 있기 때문에, 내부에서도 굳이 다시 Task {}로 감쌀 필요는 없어.
    > 
    
    > → 이는 오히려 흐름 추적을 어렵게 만들 수 있고, 테스트에서 겉도는 Task가 생길 수 있어.
    > 
    
    🔧 **개선**:
    
    ```
    await EventBus.shared.post(.transformFinished(...))
    ```
    
    ---
    
    ### **2. 루프 재귀 호출 구조 개선 가능**
    
    현재 구조는 loop()가 끝난 후, if !queue.isEmpty면 다시 loop()를 재귀 호출함:
    
    ```
    if !transformQueue.isEmpty {
        isRunning = true
        Task { try await self.loop() }
    }
    ```
    
    > 이건 동작은 맞지만,
    > 
    > 
    > **루프가 끝나는 지점에서 스스로 재시작을 트리거**
    > 
    
    🔧 **대안**:
    
    - loop() 내부에서 while true로 돌리고, 비어있을 경우 Task.sleep 또는 await yield()로 살짝 기다리는 방식 고려 가능.
    
    ---
    
    ## **✨ 객체지향 설계로서의 총평**
    
    | **항목** | **평가** |
    | --- | --- |
    | 역할 응집 | ✅ 명확히 변환 루퍼의 책임에 집중 |
    | 상태 관리 | ✅ 내부 캡슐화 잘 되어 있음 |
    | 메시지 전달 | ✅ EventBus와 협력 방식 적절 |
    | 확장성 | 🔶 uploadFinished 외의 이벤트를 처리하게 될 경우 구조 확장이 필요 |
    | 테스트 용이성 | 🔶 내부 상태 테스트 어려움 → 의존성 주입 방식으로 일부 분리 가능 |
    
    ---
    
    ## **🔚 결론**
    
    > 네가 구현한 TransformLooper는
    > 
    > 
    > **Swift actor 특성을 활용한 객체지향적 비동기 큐 처리의 좋은 예시**
    > 
    
    > 내부 책임과 상태 관리는 잘 되어 있지만,
    > 
    > 
    > **테스트 용이성**
    > 
    > **불필요한 Task 중첩**
    > 
    > **루프 설계 방식**
    > 
    
    필요하면 리팩토링 버전도 도와줄게! 😎
    

- 두 번째 목표
    
    **다이어그램 활용하기 (도식화 연습)**
    
    0730(수) - 
    
    정성스럽게 잘 정리된 README입니다! 전체적으로 **학습 기반 개발 프로젝트로서 매우 높은 완성도**를 보여주고 있고, 특히 **기능 흐름 설명 + 객체 구조 + 테스트 + 개선 내역**까지 골고루 포함된 점이 훌륭해요.
    
    요청하신 다이어그램 평가를 포함해 아래에 전체 피드백을 드릴게요.
    
    ---
    
    ## **✅ 전체 구조 피드백 요약**
    
    | **항목** | **평가** | **피드백** |
    | --- | --- | --- |
    | ✔️ 목적 설명 | 매우 명확함 | 문제를 오해한 경험까지 솔직히 담겨 있어서 학습자 관점에서 공감도가 큼 |
    | ✔️ Git 핵심 개념 정리 | 구조적으로 명확 | blob, tree, commit, index 등 객체 구분과 역할 요약이 핵심만 잘 담김 |
    | ✔️ 명령어별 흐름 정리 | 구체적이고 현실적 | init → add → commit → log 흐름이 실제 Git처럼 단계별로 잘 묘사되어 있음 |
    | ✔️ 테스트 및 개선 내역 | 실제 코드 반영 | 테스트 이름, 목적, 개선 이유가 함께 정리되어 있어 유지보수와 팀 공유에 유리함 |
    
    ---
    
    ## **📊 다이어그램 평가 (**
    
    ## **짝 설계**
    
    ## **영역)**
    
    ```
    <img width="1262" height="624" src="https://github-production-user-asset-6210df.s3.amazonaws.com/101088300/472489072-67e1a3a6-cabc-4d5f-83df-12683d9134b4.png" />
    
    ```
    
    ### **✅ 잘된 점**
    
    - **구성요소가 실제 구현 구조와 잘 대응**됨
        
        (GitAddCommand, IndexManager, Blob, EventBus, Commit, Tree 등)
        
    - 흐름이 **위→아래로 시간적/논리적 순서대로 연결**되어 있어 처음 보는 사람도 쉽게 따라갈 수 있음
    - 화살표 방향과 라벨이 명확해서 **객체 간 협력 관계**가 드러남
    - 실제 구현에서 SHA-1, zlib, .git/index 등으로 이어지는 흐름과 **직결된 설명**을 담고 있음
    
    ### **⚠️ 보완하면 좋은 점**
    
    | **항목** | **개선 제안** |
    | --- | --- |
    | SHA-256 → SHA-1 | 이미 수정 메모로 적었지만, 이미지 내 텍스트도 반영되면 더 명확함 |
    | 객체 책임이 섞여 있는 점 | EventBus의 위치나 역할이 구체적이지 않아 약간 부유하는 느낌 → 메시지 전달용이면 점선 화살표처럼 표현해도 좋음 |
    | .git 내부 저장 구조 시각화 부족 | .git/objects/, refs/heads, index, logs 등의 저장소 내부 구조가 보완되면 더욱 완전해짐 (기능 흐름도 + 저장 구조도 분리 가능) |
    
    ---
    
    ## **✨ 종합 평점 (다이어그램 포함)**
    
    | **항목** | **점수 (5점 만점)** | **비고** |
    | --- | --- | --- |
    | 이해도 | ⭐⭐⭐⭐⭐ | 처음 보는 사람도 따라가기 쉬움 |
    | 구현 대응력 | ⭐⭐⭐⭐☆ | 실제 코드 흐름과 대부분 대응되나 일부 추상 객체 위치 모호함 |
    | 시각적 전달력 | ⭐⭐⭐⭐☆ | 화살표, 구성 단위, 흐름 모두 우수 |
    | 문서 연계성 | ⭐⭐⭐⭐⭐ | README 내 설명과 매우 잘 연결됨 |
    
    **총평:** 학습용 문서로서 매우 훌륭하며, 팀 내 설계 공유나 기술 발표 자료로 사용해도 손색이 없습니다.
    
    특히, “분석 → 설계 → 구현 → 테스트 → 개선”의 흐름이 정리된 흔치 않은 문서예요. 다이어그램 역시 그 설계를 도식화한 형태로 충실합니다.
    
    ---
    
    필요하다면 **이 다이어그램을 Mermaid.js로 변환하거나**,
    
    .git 저장 구조만 따로 시각화해주는 서브 다이어그램도 함께 만들어드릴 수 있어요.
    
    원하시면 알려줘요! 😄
    
    0731(목) - 
    
    좋아요! 올려주신 구조를 기준으로 Git add → commit → log 흐름에 따라 **Mermaid 시퀀스 다이어그램**을 만들어 드릴게요. 아래는 현재 코드 구조(파일 이름 기준)로 추정 가능한 객체/모듈 간 **동작 호출 순서 흐름도**입니다:
    
    **✅ Mermaid 시퀀스 다이어그램**
    
    ```mermaid
    sequenceDiagram
        participant User
        participant MiniGit
        participant GitAddCommand
        participant IndexManager
        participant Blob
        participant GitCommitCommand
        participant Tree
        participant Commit
        participant GitLogCommand
    
        User->>MiniGit: 입력 (add, commit, log)
        MiniGit->>GitAddCommand: add 호출
        GitAddCommand->>Blob: 파일 읽고 blob 생성
        GitAddCommand->>IndexManager: index에 blob 정보 저장
        IndexManager-->>GitAddCommand: 저장 완료
        GitAddCommand-->>MiniGit: add 완료
    
        MiniGit->>GitCommitCommand: commit 호출
        GitCommitCommand->>IndexManager: index 로드
        GitCommitCommand->>Tree: tree 객체 생성
        GitCommitCommand->>Commit: commit 객체 생성
        Commit->>Commit: SHA 계산 및 압축 저장
        GitCommitCommand->>GitCommitCommand: HEAD 갱신 및 로그 추가
        GitCommitCommand-->>MiniGit: commit 완료
    
        MiniGit->>GitLogCommand: log 호출
        GitLogCommand->>GitLogCommand: HEAD → refs → commit 추적
        GitLogCommand->>Commit: commit 정보 로드
        GitLogCommand-->>MiniGit: 로그 출력
    ```
    
    ### **📝 참고 사항**
    
    - MiniGit은 main.swift 내부에서 명령어 파싱 및 호출하는 엔트리 역할로 간주했습니다.
    - IndexManager, Blob, Tree, Commit은 각각 객체 저장이나 index 관리 책임을 담당합니다.
    - GitAddCommand, GitCommitCommand, GitLogCommand는 각각의 명령을 수행하는 커맨드 객체입니다.
    
    ---
    
    ### **✅ 추가로 만들 수 있는 다이어그램**
    
    - .git 디렉토리 저장 구조 (objects/index/refs/logs)
    - Git 내부 객체(Blob/Tree/Commit)의 연결 구조 (Tree ↔ Blob, Commit ↔ Tree 등)
    
    필요하시면 이어서 그려드릴게요!


####  J295 황소정
- 2개의 프로젝트에 대해 시간 설정과 함께 각 단계별 목표와 상세 사항을 요청하였습니다

## 1. 비동기 동영상 프로젝트 – 소요 시간 계획 및 달성표

| 단계           | 주요 작업 내용                 | 예상 소요 시간 | 실제 소요 시간 | 달성/비고 |
| ------------ | ------------------------ | :------: | :------: | :---- |
| 1. 요구사항 분석   | 요구사항 정리 및 모듈 분리          |   1.5h   |   2h   |   v   |
| 2. 설계        | 전체 구조/모듈 설계, 이벤트 흐름      |    2h    |     2h   |   v    |
| 3. 환경/기초 세팅  | 폴더 구조, 패키지, 기본 코드 작성     |   0.5h   |   0.3h       |     v  |
| 4. 각 모듈 구현   | Queue, Looper, Manager 등 |    3h    |    5h    |    v   |
| 5. 비동기 로직 작성 | 이벤트, 큐, 상태 변화 처리         |    2h    |    3h   |    v   |
| 6. 테스트       | 단위/통합 테스트, 예제 시나리오 실행    |   1.5h   |   3h    |    x   |
| 7. 문서화/정리    | 코드/구조/동작 원리 문서화          |    1h    |      0.5h    |    x   |
| 8. 회고/정리     | 어려웠던 점, 개선점, 정리 노트 작성    |   0.5h   |     x     |     x  |
| **총합**       |                          |  **12h** |      15.8h    |   x    |

---
## 계획 상세 목표

1. **요구사항 분석**
   이 단계에서는 시스템이 어떤 기능을 가져야 하고, 어떤 목표를 달성해야 하는지 명확히 정의합니다. 동영상의 등록, 변환, 검증이 각각 어떤 의미를 가지는지와 입력 데이터의 형태, 처리 흐름, 그리고 최종적으로 사용자가 기대하는 결과가 무엇인지 정리합니다. 이를 바탕으로 각 역할을 담당할 모듈(예: 큐, 루퍼, 매니저 등)을 식별하고, 전체적인 프로젝트의 큰 그림을 잡습니다.

2. **설계**
   요구사항을 바탕으로 전체 시스템 구조와 각 모듈의 책임, 그리고 이들 사이의 이벤트 흐름을 도식화하거나 표로 정리합니다. Queue, Looper, Manager, Dashboard 등 각 요소들이 어떤 역할을 맡는지, 실제로 어떤 이벤트가 발생하며 데이터와 제어 흐름이 어떻게 이동하는지를 구체적으로 설계합니다.

3. **환경/기초 세팅**
   본격적인 개발에 앞서, 프로젝트 폴더 구조를 만들고, Node.js 및 필요한 패키지(EventEmitter 등)를 설치합니다. 초기화 스크립트와 기본 입출력 코드, 테스트용 파일들을 준비하여 빠르게 테스트할 수 있는 환경을 구축합니다.

4. **각 모듈 구현**
   설계 단계에서 도출한 각 모듈(예: RegistrationQueue/Looper, TransformQueue/Looper, VerificationQueue/Looper, Manager, Dashboard 등)을 실제로 코드로 작성합니다. 각 큐와 루퍼가 데이터의 흐름을 어떻게 관리하는지, 상태 변화를 어떻게 처리하는지를 중심으로 구현합니다.

5. **비동기 로직 작성**
   이벤트 기반 비동기 처리를 실제 코드에 반영하는 단계입니다. 루퍼가 주기적으로 큐를 체크하고 작업이 있다면 다음 단계로 넘기거나, 상태 변화 이벤트를 발생시키도록 합니다. Node.js의 이벤트 처리 방식을 적극 활용하여 각 단계가 독립적으로 비동기적으로 동작하게 만듭니다.

6. **테스트**
   각 모듈별로 단위 테스트를 진행하고, 전체 플로우를 점검할 수 있는 통합 테스트도 작성합니다. 실제로 예시 영상을 등록해서 최종 처리까지 전체 시나리오를 실행해 봄으로써, 예상치 못한 버그나 병목, 이벤트 미수신 상황을 직접 확인하고 수정합니다.

7. **문서화/정리**
   코드에 충분한 주석을 달고, 전체 구조와 동작 원리를 다이어그램이나 설명글로 문서화합니다. 각 단계별로 무슨 일이 일어나는지, 모듈의 책임과 역할이 무엇인지 등, 나중에 다시 보거나 다른 사람에게 설명할 때 도움이 되는 정보를 정리합니다.

8. **회고/정리**
   구현과 테스트 과정에서 느낀 점, 힘들었던 부분, 개선이 필요한 점이나 다음에 다시 시도해보고 싶은 아이디어를 정리합니다. 이 회고 과정을 통해 이번 프로젝트를 통해 배운 점과 남은 과제를 명확히 인식할 수 있습니다.


---

## 2. Git 구현 프로젝트 – 소요 시간 계획 및 달성표

| 단계                  | 주요 작업 내용                  | 예상 소요 시간 | 실제 소요 시간 | 달성/비고 |
| ------------------- | ------------------------- | :------: | :------: | :---- |
| 1. 요구사항 분석          | 구현할 git 기능 선정, 주요 목표 명확화  |    1h    |     0.5h     |   v    |
| 2. 구조/흐름 설계         | .git 구조/오브젝트/명령 흐름 설계     |   1.5h   |   2h    |   v    |
| 3. 기초 세팅            | 환경/폴더, 기본 코드, 테스트 파일 작성   |   0.5h   |    0.3h    |   v    |
| 4. Blob 구현          | blob 객체 생성/저장/해시 처리       |    1h    |    3h    |    v   |
| 5. Index 구현         | index 파일 포맷, 파싱/수정/리스트 구현 |    2h    |    5h    |   v    |
| 6. Tree/Commit 구현   | tree, commit 객체 생성/연결     |    2h    |       x   |    v   |
| 7. git add/commit 등 | add/commit 명령어, 콘솔 입력 처리  |   1.5h   |     7h     |   v    |
| 8. 로그/상태 분석         | log, status 등 분석/출력 구현    |    1h    |    5h   |    v   |
| 9. 문서화/정리           | 전체 구조/동작 원리 문서화           |    1h    |    2h   |   v    |
| 10. 회고/리팩터링         | 코드 개선, 느낀 점, 노트 작성        |   0.5h   |    1h    |   v    |
| **총합**              |                           |  **12h** |     23.8h     |   x    |


## 2. Git 구현 프로젝트 – 단계별 상세 설명

1. **요구사항 분석**
   어떤 git 명령어를 어떤 수준까지 직접 구현할 것인지 결정합니다. 예를 들어, git add, commit, log 등 각 명령어가 내부적으로 어떤 역할을 하고, 어떤 오브젝트와 파일에 영향을 주는지 분석합니다. 구현 범위와 목표를 명확히 합니다.

2. **구조/흐름 설계**
   .git 폴더의 실제 구조(디렉토리, 파일)와 각 오브젝트(blob, tree, commit)의 저장 및 참조 구조를 설계합니다. 명령어별 내부 데이터 흐름(예: 해시 생성, 오브젝트 생성, 인덱스 파일 갱신 등)을 표나 그림으로 정리하여, 전체 동작 방식을 파악합니다.

3. **기초 세팅**
   Node.js 환경을 준비하고, 테스트용 저장소 디렉토리와 .git 구조, 샘플 파일을 만듭니다. 개발에 필요한 라이브러리(fs, zlib, crypto 등)를 설치하고, 기본 입출력 코드와 콘솔 명령 인터페이스도 준비합니다.

4. **Blob 구현**
   파일 내용을 읽어 “blob {size}\0{content}” 형식의 blob 오브젝트를 생성하고, SHA-1 해시로 파일명을 정하여 .git/objects 디렉토리에 저장하는 기능을 구현합니다. git의 오브젝트 저장 구조를 직접 체험합니다.

5. **Index 구현**
   .git/index 파일을 직접 읽고, 바이너리 포맷을 파싱하여 엔트리 리스트를 관리합니다. add 명령어가 index에 파일을 어떻게 추가하는지, 새로운 엔트리 추가 및 수정, 그리고 현재 인덱스 상태를 리스트로 출력하는 기능을 구현합니다.

6. **Tree/Commit 구현**
   디렉토리 구조에서 파일 정보를 tree 오브젝트로 묶고, 커밋 오브젝트를 직접 생성하여 tree와 연결합니다. 커밋에는 parent, author, 메시지 등 메타데이터를 직접 다루며, 오브젝트간의 참조 구조를 명확히 합니다.

7. **git add/commit 등 명령어 구현**
   사용자로부터 입력을 받아 실제 git 명령어처럼 동작하는 기능을 만듭니다. 예를 들어, `node app.js git add file.txt` 혹은 `node app.js git commit -m "메시지"`와 같은 명령이 내부적으로 오브젝트 생성과 인덱스 갱신을 수행하도록 직접 구현합니다.

8. **로그/상태 분석 기능**
   commit log, 파일 상태(status) 등을 직접 출력하는 기능을 구현합니다. 커밋 리스트를 추적하고, 브랜치 포인터 이동 등 git의 내부 동작 원리를 코드로 재현합니다.

9. **문서화/정리**
   구현한 git 구조와 각 오브젝트, 파일, 명령의 동작 원리, 그리고 사용 방법을 문서화합니다. 필요한 경우 데이터 구조도나 흐름도를 추가하여 설명을 더합니다.

10. **회고/리팩터링**
    구현 과정에서 어려웠던 점, 새롭게 알게 된 점, 코드 리팩터링 포인트, 나중에 도전해보고 싶은 과제 등을 정리합니다. 이를 통해 자기 피드백과 성장을 기록합니다.

### 사용해보면서 느낀점
>처음에 혼자서 프로젝트 계획을 세울 때는 뭐부터 해야 할지 막막해서 고민이 많았습니다. “일단 시작은 해야겠는데, 어디서부터 손을 대야 하지?” 하는 생각이 들었기 때문입니다. 그러다 이번처럼 단계별로 작업을 쭉 나눠서 계획해보니, 해야 할 일들이 훨씬 뚜렷하게 보이기 시작했습니다.

한 번에 모든 걸 하려고 하지 않고, 요구사항 정리부터 설계, 환경 세팅, 모듈별 구현, 테스트, 문서화, 회고까지 차근차근 쪼개 놓으니까 각 단계에서 집중할 것들이 명확해지고, “지금은 이걸 하면 되고, 다음에는 저걸 하면 된다”는 흐름이 잡히니까 생각보다 덜 막혔던 것 같습니다.

---
#### J252 조아령

## 실천

<img width="1002" height="431" alt="릴프1" src="https://github.com/user-attachments/assets/8910c8c7-ee0e-4b71-926e-691446b02f76" />

<img width="987" height="494" alt="릴프2" src="https://github.com/user-attachments/assets/d75d2475-b2d8-4e6b-b215-fe9c41fc98ab" />

<img width="737" height="571" alt="릴프3" src="https://github.com/user-attachments/assets/caf51a43-2e4c-491e-9150-ea10a2a9629c" />

## GPT가 해줄 수 있는 것

### 🔧 제가 해드릴 수 있는 것

| 작업 | 설명 |
| --- | --- |
| 🧘 휴식 계획 세우기 | 원하는 스타일에 맞춰 하루 또는 일주일 계획 구성 |
| 📆 일정표로 변환 | 타임블록 형식으로 정리된 계획 |
| 🔔 알림 연동 안내 | 구글 캘린더나 휴대폰 알림 설정 방법 가이드 제공 |

## Perplexity가 해줄 수 있는 것

아래와 같은 방식으로 도움을 드릴 수 있습니다:

- 원하는 휴식 계획을 구체적으로 작성해 드리고, 이를 복사해서 직접 캘린더 등에 붙여넣기 하실 수 있게 안내해드립니다.
- 일정표, 시간표, 체크리스트 등 시각적으로 정리해 드릴 수 있습니다.
- 알림이나 일정 연동이 필요하다면, 작성해드린 내용을 구글 캘린더, 네이버 캘린더 등 본인이 사용하는 서비스에 직접 등록하시는 방법을 안내해드립니다.

## 느낀점

이번 기회에 Gemini에서 반복 일정을 자동으로 등록하고 관리할 수 있는 기능이 있다는 걸 알게 되어 흥미로웠다. Perplexity나 GPT에 같은 질문을 했을 땐, 일정 자체는 만들어 줄 수 있지만 실제 캘린더 연동까지는 지원하지 않는다고 답변을 얻어 Gemini가 자동화 측면에서 좀 더 실용적인 선택일 수 있다는 생각이 들었다. 특히 반복되는 일정을 간편하게 관리하고 싶은 경우엔 Gemini가 일정 등록과 알림 연동이 매끄러워 효율적이라는 생각이 들었다.

다만, 막상 휴식 계획처럼 정량화하기 어려운 내용을 다룰 때는 AI의 도움에 한계가 있다는 점도 느꼈다. 먼저, 내가 어떤 상태인지 얼마나 피곤한지, 어떤 활동을 원하지 않는지 등을 상세히 입력해야 의미 있는 답변을 받을 수 있다는 점이 번거롭게 느껴졌고, 추천 받는 활동들도 결국 내가 이미 예상할 수 있는 범위에서 크게 벗어나지 않았다. 그래서 오히려 이러한 계획은 스스로 고민하고 결정하는 게 더 낫겠다는 생각이 들었다. 단순히 AI가 주는 선택지를 고르는 방식으로는 만족스러운 휴식 계획을 세우기 어려웠다.

이번 경험을 통해 얻은 결론은, 정성적인 질문이나 감정에 기반한 휴식 활동 추천보다는, 반복적인 작업이나 자동화가 필요한 영역에서 AI 도구를 활용하는 것이 더 실용적이라는 점이다. 계획 세우는 걸 도와주는 도구라기보다는 내가 만든 계획을 보기 좋게 정리해주고 반복 가능하도록 설정해주는 ‘보조자’로서 활용하는 편이 더 만족도가 높은 거 같다.


---
#### J138 서윤주

Day11-12 

Q : 해시맵을 함수형 프로그래밍으로 구현하고 이번에 sha를 공부했는데 이거와 연관해서 공부할 학습 키워드가 있을까?

## 연결 포인트 요약

| 네 학습 내용 | 연결 포인트 | 의미 |
| --- | --- | --- |
| 함수형 해시맵 구현 | **해시 충돌 처리, 해시 함수 설계, 불변성** | 직접 구현한 구조를 현실의 해시 기반 시스템과 비교 가능 |
| SHA 해시 학습 | **내용 기반 주소 지정(content-addressable)** | Git의 핵심 원리와 해시맵 key-value 접근 모델이 맞닿아 있음 |
| 함수형 → Git 연결 | **불변 구조 + 해시 기반 데이터 저장** | Git도 사실상 거대한 해시맵처럼 동작함 (SHA: 값 → 위치 매핑) |

### **Hash Collision (해시 충돌)**

- **설명**: 서로 다른 내용이 동일한 해시값을 가질 가능성
- **연결 이유**: 해시맵 구현 시 충돌 처리 방식을 생각해봤을 거야 (open addressing, chaining 등)
    
    Git에서도 실제로는 SHA-1 충돌 방지를 위해 SHA-256로 전환 중이야
    
- 공부 포인트:
    - SHA-1의 보안 문제와 충돌 사례
    - Git의 SHA-256 전환 이슈

Day13-14 

Q: 지난시간에 PUB-SUB패턴에 대해서 공부하고 이번에 이벤트 매니저를 만들어서 비동기처리를 하는걸 공부했는데 이와 연관해서 공부할 학습 키워드가 있을까?

## 🔁 이전 학습과 연관된 Pub-Sub 확장 키워드

| 학습 주제 | 연결 포인트 | 이유 |
| --- | --- | --- |
| Pub-Sub 패턴 | **EventEmitter, Observer 패턴, 이벤트 루프, 이벤트 큐** | Pub-Sub은 Node.js `EventEmitter` 기반 구현에서 흔히 사용되며, JS 비동기 구조와 직결됨 |
| 이벤트 매니저 구현 | **비동기 흐름 제어, 메시지 브로커 역할** | 이벤트 발생/리스닝/처리 로직 설계 경험은 분산 시스템 메시징 개념과 이어짐 |
| 비동기 처리 | **Promise, async/await, 이벤트 루프** | Pub-Sub은 비동기 구조를 기반으로 하므로 JS의 이벤트 루프 동작과 연결됨 |
| 이벤트 기반 시스템 설계 | **비동기 큐, 백프레셔(backpressure), 메시지 지연 처리** | 크롤러나 영상 처리 시스템에서 비동기 이벤트 처리는 핵심 동작 흐름임 |

### 1. **Observer Pattern vs Pub-Sub Pattern**

- **설명**: 둘 다 이벤트 기반이지만, 구체적인 차이가 있음
    - Observer: 객체 간 1:N 직접 연결 (tight coupling)
    - Pub-Sub: 중간에 **이벤트 버스**가 있어 **발행자와 구독자가 분리됨 (loose coupling)**
- **이유**: 이벤트 매니저를 만들었으면 구조적 차이를 이해하고 **언제 어떤 걸 쓰는지**를 아는 게 중요함

### 2. **메시지 브로커 시스템 구조**

- **설명**: 실제 Pub-Sub 시스템에서는 Kafka, Redis PubSub, RabbitMQ 등을 사용
- **이유**: 너가 만든 이벤트 매니저는 일종의 **간단한 메시지 브로커** 역할을 하므로, **확장형 시스템**으로 연결해볼 수 있음
- 공부 포인트:
    - Kafka와 Redis PubSub 구조 비교
    - 메시지 지연, 누락, 순서 보장 등 처리 방식

수행 후 느낀점

ai가 정리해 준 내용으로 더 많은 공부를 할 수 있어서 좋았습니다. 더 많은 내용은 서치가 필요했지만 정리를 깔끔하게 해주어서 공부하기에 편리했던 것 같습니다. 학습도구로서의 ai의 장점을 많이 알게된 퀘스트였습니다.
